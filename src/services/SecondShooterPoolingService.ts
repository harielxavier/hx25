interface SecondShooter {
  id: string;
  name: string;
  email: string;
  phone: string;
  profileImage?: string;
  location: {
    city: string;
    state: string;
    coordinates: {
      lat: number;
      lng: number;
    };
  };
  availability: AvailabilitySlot[];
  skills: ShooterSkill[];
  equipment: EquipmentItem[];
  rates: ShooterRates;
  portfolio: PortfolioItem[];
  ratings: ShooterRating[];
  preferences: ShooterPreferences;
  status: 'active' | 'inactive' | 'busy' | 'vacation';
  joinedAt: Date;
  lastActive: Date;
  completedJobs: number;
  averageRating: number;
  responseTime: number; // average minutes to respond
  reliability: number; // 0-1 score
}

interface AvailabilitySlot {
  id: string;
  date: Date;
  startTime: string; // "09:00"
  endTime: string; // "17:00"
  type: 'available' | 'preferred' | 'maybe' | 'unavailable';
  jobType?: 'wedding' | 'portrait' | 'corporate' | 'event' | 'any';
  notes?: string;
  recurring?: {
    pattern: 'weekly' | 'monthly';
    endDate?: Date;
  };
}

interface ShooterSkill {
  category: 'wedding' | 'portrait' | 'corporate' | 'event' | 'commercial' | 'sports' | 'nature';
  level: 'beginner' | 'intermediate' | 'advanced' | 'expert';
  yearsExperience: number;
  specialties: string[];
  certifications?: string[];
}

interface EquipmentItem {
  type: 'camera' | 'lens' | 'flash' | 'tripod' | 'drone' | 'audio' | 'other';
  brand: string;
  model: string;
  condition: 'excellent' | 'good' | 'fair' | 'poor';
  owned: boolean; // true if owned, false if rented
  notes?: string;
}

interface ShooterRates {
  hourly: number;
  halfDay: number; // 4 hours
  fullDay: number; // 8 hours
  wedding: number; // full wedding package
  travel: {
    local: number; // per mile
    regional: number; // per mile
    overnight: number; // per day
  };
  rush: {
    sameDay: number; // multiplier (e.g., 1.5x)
    nextDay: number; // multiplier (e.g., 1.25x)
  };
  currency: 'USD';
}

interface PortfolioItem {
  id: string;
  title: string;
  description: string;
  imageUrl: string;
  category: ShooterSkill['category'];
  shootDate: Date;
  featured: boolean;
}

interface ShooterRating {
  id: string;
  jobId: string;
  primaryPhotographer: string;
  rating: number; // 1-5
  review: string;
  categories: {
    technical: number; // 1-5
    communication: number; // 1-5
    reliability: number; // 1-5
    creativity: number; // 1-5
    professionalism: number; // 1-5
  };
  createdAt: Date;
  verified: boolean;
}

interface ShooterPreferences {
  maxTravelDistance: number; // miles
  preferredJobTypes: ShooterSkill['category'][];
  minimumNotice: number; // hours
  workingHours: {
    start: string; // "08:00"
    end: string; // "20:00"
  };
  weekendPremium: number; // multiplier
  holidayPremium: number; // multiplier
  autoAccept: {
    enabled: boolean;
    conditions: {
      maxDistance: number;
      minRate: number;
      preferredClients: string[];
    };
  };
  notifications: {
    email: boolean;
    sms: boolean;
    push: boolean;
    frequency: 'immediate' | 'hourly' | 'daily';
  };
}

interface ShootingOpportunity {
  id: string;
  primaryPhotographerId: string;
  title: string;
  description: string;
  jobType: ShooterSkill['category'];
  date: Date;
  startTime: string;
  endTime: string;
  location: {
    venue: string;
    address: string;
    city: string;
    state: string;
    coordinates: {
      lat: number;
      lng: number;
    };
  };
  requirements: {
    experience: ShooterSkill['level'];
    equipment: string[];
    skills: string[];
    dresscode: string;
  };
  compensation: {
    type: 'hourly' | 'flat' | 'percentage';
    amount: number;
    currency: 'USD';
    includesTravel: boolean;
    includesMeals: boolean;
  };
  status: 'open' | 'claimed' | 'filled' | 'cancelled' | 'completed';
  postedAt: Date;
  deadline: Date; // when applications close
  maxApplicants: number;
  selectedShooter?: string;
  applicants: OpportunityApplication[];
  urgency: 'low' | 'medium' | 'high' | 'urgent';
  clientInfo: {
    name: string;
    type: 'wedding' | 'corporate' | 'private' | 'event';
    specialRequests?: string[];
  };
}

interface OpportunityApplication {
  id: string;
  shooterId: string;
  opportunityId: string;
  message: string;
  proposedRate?: number;
  availability: 'confirmed' | 'tentative' | 'unavailable';
  appliedAt: Date;
  status: 'pending' | 'accepted' | 'rejected' | 'withdrawn';
  autoGenerated: boolean; // true if auto-applied based on preferences
}

interface PoolingNetwork {
  id: string;
  name: string;
  description: string;
  adminId: string;
  members: string[]; // shooter IDs
  location: {
    city: string;
    state: string;
    radius: number; // miles
  };
  rules: NetworkRules;
  stats: NetworkStats;
  createdAt: Date;
  isPublic: boolean;
  inviteCode?: string;
}

interface NetworkRules {
  minimumRating: number;
  minimumJobs: number;
  requiresApproval: boolean;
  allowRateNegotiation: boolean;
  maxResponseTime: number; // hours
  qualityStandards: string[];
  codeOfConduct: string[];
}

interface NetworkStats {
  totalMembers: number;
  activeMembers: number;
  totalOpportunities: number;
  completedJobs: number;
  averageRating: number;
  averageResponseTime: number;
  successRate: number; // percentage of filled opportunities
}

class SecondShooterPoolingService {
  private shooters: Map<string, SecondShooter> = new Map();
  private opportunities: Map<string, ShootingOpportunity> = new Map();
  private networks: Map<string, PoolingNetwork> = new Map();
  private applications: Map<string, OpportunityApplication> = new Map();

  constructor() {
    this.initializeMockData();
  }

  /**
   * Initialize with mock data for demonstration
   */
  private initializeMockData() {
    // Mock second shooters
    const mockShooters: SecondShooter[] = [
      {
        id: 'shooter_1',
        name: 'Sarah Johnson',
        email: 'sarah@example.com',
        phone: '+1-555-0101',
        location: {
          city: 'New York',
          state: 'NY',
          coordinates: { lat: 40.7128, lng: -74.0060 }
        },
        availability: [],
        skills: [
          {
            category: 'wedding',
            level: 'advanced',
            yearsExperience: 5,
            specialties: ['ceremony', 'reception', 'portraits']
          }
        ],
        equipment: [
          {
            type: 'camera',
            brand: 'Canon',
            model: '5D Mark IV',
            condition: 'excellent',
            owned: true
          }
        ],
        rates: {
          hourly: 75,
          halfDay: 280,
          fullDay: 500,
          wedding: 800,
          travel: { local: 0.65, regional: 0.65, overnight: 150 },
          rush: { sameDay: 1.5, nextDay: 1.25 },
          currency: 'USD'
        },
        portfolio: [],
        ratings: [],
        preferences: {
          maxTravelDistance: 50,
          preferredJobTypes: ['wedding', 'portrait'],
          minimumNotice: 24,
          workingHours: { start: '08:00', end: '22:00' },
          weekendPremium: 1.2,
          holidayPremium: 1.5,
          autoAccept: {
            enabled: true,
            conditions: {
              maxDistance: 25,
              minRate: 75,
              preferredClients: []
            }
          },
          notifications: {
            email: true,
            sms: true,
            push: true,
            frequency: 'immediate'
          }
        },
        status: 'active',
        joinedAt: new Date('2024-01-15'),
        lastActive: new Date(),
        completedJobs: 23,
        averageRating: 4.8,
        responseTime: 15,
        reliability: 0.95
      },
      {
        id: 'shooter_2',
        name: 'Mike Chen',
        email: 'mike@example.com',
        phone: '+1-555-0102',
        location: {
          city: 'Brooklyn',
          state: 'NY',
          coordinates: { lat: 40.6782, lng: -73.9442 }
        },
        availability: [],
        skills: [
          {
            category: 'corporate',
            level: 'expert',
            yearsExperience: 8,
            specialties: ['headshots', 'events', 'product']
          }
        ],
        equipment: [
          {
            type: 'camera',
            brand: 'Sony',
            model: 'A7R IV',
            condition: 'excellent',
            owned: true
          }
        ],
        rates: {
          hourly: 85,
          halfDay: 320,
          fullDay: 600,
          wedding: 900,
          travel: { local: 0.65, regional: 0.65, overnight: 175 },
          rush: { sameDay: 1.6, nextDay: 1.3 },
          currency: 'USD'
        },
        portfolio: [],
        ratings: [],
        preferences: {
          maxTravelDistance: 75,
          preferredJobTypes: ['corporate', 'event'],
          minimumNotice: 48,
          workingHours: { start: '09:00', end: '18:00' },
          weekendPremium: 1.3,
          holidayPremium: 1.6,
          autoAccept: {
            enabled: false,
            conditions: {
              maxDistance: 30,
              minRate: 85,
              preferredClients: []
            }
          },
          notifications: {
            email: true,
            sms: false,
            push: true,
            frequency: 'hourly'
          }
        },
        status: 'active',
        joinedAt: new Date('2023-08-20'),
        lastActive: new Date(),
        completedJobs: 41,
        averageRating: 4.9,
        responseTime: 45,
        reliability: 0.98
      }
    ];

    mockShooters.forEach(shooter => {
      this.shooters.set(shooter.id, shooter);
    });
  }

  /**
   * Post a new shooting opportunity
   */
  async postOpportunity(opportunity: Omit<ShootingOpportunity, 'id' | 'postedAt' | 'applicants' | 'status'>): Promise<ShootingOpportunity> {
    const newOpportunity: ShootingOpportunity = {
      ...opportunity,
      id: `opp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      postedAt: new Date(),
      applicants: [],
      status: 'open'
    };

    this.opportunities.set(newOpportunity.id, newOpportunity);

    // Auto-notify eligible shooters
    await this.notifyEligibleShooters(newOpportunity);

    // Process auto-applications
    await this.processAutoApplications(newOpportunity);

    return newOpportunity;
  }

  /**
   * Find eligible shooters for an opportunity
   */
  async findEligibleShooters(opportunityId: string): Promise<SecondShooter[]> {
    const opportunity = this.opportunities.get(opportunityId);
    if (!opportunity) {
      throw new Error('Opportunity not found');
    }

    const eligibleShooters: SecondShooter[] = [];

    for (const shooter of this.shooters.values()) {
      if (await this.isShooterEligible(shooter, opportunity)) {
        eligibleShooters.push(shooter);
      }
    }

    // Sort by relevance score
    return eligibleShooters.sort((a, b) => {
      const scoreA = this.calculateRelevanceScore(a, opportunity);
      const scoreB = this.calculateRelevanceScore(b, opportunity);
      return scoreB - scoreA;
    });
  }

  /**
   * Check if shooter is eligible for opportunity
   */
  private async isShooterEligible(shooter: SecondShooter, opportunity: ShootingOpportunity): Promise<boolean> {
    // Check status
    if (shooter.status !== 'active') return false;

    // Check location/travel distance
    const distance = this.calculateDistance(
      shooter.location.coordinates,
      opportunity.location.coordinates
    );
    if (distance > shooter.preferences.maxTravelDistance) return false;

    // Check availability
    if (!this.isShooterAvailable(shooter, opportunity.date, opportunity.startTime, opportunity.endTime)) {
      return false;
    }

    // Check experience level
    const hasRequiredSkill = shooter.skills.some(skill => 
      skill.category === opportunity.jobType && 
      this.isExperienceLevelSufficient(skill.level, opportunity.requirements.experience)
    );
    if (!hasRequiredSkill) return false;

    // Check minimum notice
    const hoursUntilJob = (opportunity.date.getTime() - Date.now()) / (1000 * 60 * 60);
    if (hoursUntilJob < shooter.preferences.minimumNotice) return false;

    // Check equipment requirements
    if (!this.hasRequiredEquipment(shooter, opportunity.requirements.equipment)) {
      return false;
    }

    return true;
  }

  /**
   * Calculate relevance score for shooter-opportunity matching
   */
  private calculateRelevanceScore(shooter: SecondShooter, opportunity: ShootingOpportunity): number {
    let score = 0;

    // Rating weight (40%)
    score += shooter.averageRating * 8;

    // Experience weight (25%)
    const relevantSkill = shooter.skills.find(skill => skill.category === opportunity.jobType);
    if (relevantSkill) {
      const experienceScore = {
        'beginner': 1,
        'intermediate': 2,
        'advanced': 3,
        'expert': 4
      }[relevantSkill.level];
      score += experienceScore * 6.25;
    }

    // Reliability weight (20%)
    score += shooter.reliability * 20;

    // Response time weight (10%)
    const responseScore = Math.max(0, 10 - (shooter.responseTime / 60)); // Better score for faster response
    score += responseScore;

    // Distance penalty (5%)
    const distance = this.calculateDistance(
      shooter.location.coordinates,
      opportunity.location.coordinates
    );
    const distanceScore = Math.max(0, 5 - (distance / 10)); // Penalty for distance
    score += distanceScore;

    return score;
  }

  /**
   * Apply for an opportunity
   */
  async applyForOpportunity(
    shooterId: string, 
    opportunityId: string, 
    application: Omit<OpportunityApplication, 'id' | 'shooterId' | 'opportunityId' | 'appliedAt' | 'status' | 'autoGenerated'>
  ): Promise<OpportunityApplication> {
    const shooter = this.shooters.get(shooterId);
    const opportunity = this.opportunities.get(opportunityId);

    if (!shooter) throw new Error('Shooter not found');
    if (!opportunity) throw new Error('Opportunity not found');
    if (opportunity.status !== 'open') throw new Error('Opportunity is no longer open');

    // Check if already applied
    const existingApplication = opportunity.applicants.find(app => app.shooterId === shooterId);
    if (existingApplication) {
      throw new Error('Already applied for this opportunity');
    }

    const newApplication: OpportunityApplication = {
      ...application,
      id: `app_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      shooterId,
      opportunityId,
      appliedAt: new Date(),
      status: 'pending',
      autoGenerated: false
    };

    this.applications.set(newApplication.id, newApplication);
    opportunity.applicants.push(newApplication);

    // Notify primary photographer
    await this.notifyPrimaryPhotographer(opportunity, newApplication);

    return newApplication;
  }

  /**
   * Select a shooter for an opportunity
   */
  async selectShooter(opportunityId: string, shooterId: string): Promise<void> {
    const opportunity = this.opportunities.get(opportunityId);
    if (!opportunity) throw new Error('Opportunity not found');

    const application = opportunity.applicants.find(app => app.shooterId === shooterId);
    if (!application) throw new Error('Application not found');

    // Update opportunity
    opportunity.selectedShooter = shooterId;
    opportunity.status = 'filled';

    // Update application statuses
    opportunity.applicants.forEach(app => {
      if (app.shooterId === shooterId) {
        app.status = 'accepted';
      } else {
        app.status = 'rejected';
      }
    });

    // Notify all applicants
    await this.notifyApplicationResults(opportunity);

    // Create calendar event for selected shooter
    await this.createCalendarEvent(opportunity, shooterId);
  }

  /**
   * Get opportunities for a shooter
   */
  async getOpportunitiesForShooter(shooterId: string, filters?: {
    jobType?: ShooterSkill['category'];
    maxDistance?: number;
    dateRange?: { start: Date; end: Date };
    urgency?: ShootingOpportunity['urgency'];
  }): Promise<ShootingOpportunity[]> {
    const shooter = this.shooters.get(shooterId);
    if (!shooter) throw new Error('Shooter not found');

    let opportunities = Array.from(this.opportunities.values()).filter(opp => 
      opp.status === 'open' && 
      opp.deadline > new Date()
    );

    // Apply filters
    if (filters) {
      if (filters.jobType) {
        opportunities = opportunities.filter(opp => opp.jobType === filters.jobType);
      }

      if (filters.maxDistance !== undefined) {
        opportunities = opportunities.filter(opp => {
          const distance = this.calculateDistance(
            shooter.location.coordinates,
            opp.location.coordinates
          );
          return distance <= filters.maxDistance!;
        });
      }

      if (filters.dateRange) {
        opportunities = opportunities.filter(opp => 
          opp.date >= filters.dateRange!.start && 
          opp.date <= filters.dateRange!.end
        );
      }

      if (filters.urgency) {
        opportunities = opportunities.filter(opp => opp.urgency === filters.urgency);
      }
    }

    // Filter by eligibility
    const eligibleOpportunities: ShootingOpportunity[] = [];
    for (const opp of opportunities) {
      if (await this.isShooterEligible(shooter, opp)) {
        eligibleOpportunities.push(opp);
      }
    }

    // Sort by relevance and urgency
    return eligibleOpportunities.sort((a, b) => {
      const urgencyWeight = { urgent: 4, high: 3, medium: 2, low: 1 };
      const urgencyDiff = urgencyWeight[b.urgency] - urgencyWeight[a.urgency];
      
      if (urgencyDiff !== 0) return urgencyDiff;
      
      const scoreA = this.calculateRelevanceScore(shooter, a);
      const scoreB = this.calculateRelevanceScore(shooter, b);
      return scoreB - scoreA;
    });
  }

  /**
   * Get shooter statistics
   */
  getShooterStats(shooterId: string): {
    totalApplications: number;
    acceptedApplications: number;
    successRate: number;
    averageRating: number;
    totalEarnings: number;
    completedJobs: number;
    responseTime: number;
    reliability: number;
  } {
    const shooter = this.shooters.get(shooterId);
    if (!shooter) throw new Error('Shooter not found');

    const applications = Array.from(this.applications.values()).filter(app => 
      app.shooterId === shooterId
    );

    const acceptedApplications = applications.filter(app => app.status === 'accepted');

    return {
      totalApplications: applications.length,
      acceptedApplications: acceptedApplications.length,
      successRate: applications.length > 0 ? acceptedApplications.length / applications.length : 0,
      averageRating: shooter.averageRating,
      totalEarnings: this.calculateTotalEarnings(shooterId),
      completedJobs: shooter.completedJobs,
      responseTime: shooter.responseTime,
      reliability: shooter.reliability
    };
  }

  /**
   * Update shooter availability
   */
  async updateShooterAvailability(shooterId: string, availability: AvailabilitySlot[]): Promise<void> {
    const shooter = this.shooters.get(shooterId);
    if (!shooter) throw new Error('Shooter not found');

    shooter.availability = availability;
    shooter.lastActive = new Date();

    // Check for new matching opportunities
    await this.checkForNewMatches(shooterId);
  }

  /**
   * Rate a second shooter after a job
   */
  async rateShooter(
    shooterId: string, 
    jobId: string, 
    rating: Omit<ShooterRating, 'id' | 'createdAt' | 'verified'>
  ): Promise<void> {
    const shooter = this.shooters.get(shooterId);
    if (!shooter) throw new Error('Shooter not found');

    const newRating: ShooterRating = {
      ...rating,
      id: `rating_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date(),
      verified: true
    };

    shooter.ratings.push(newRating);

    // Recalculate average rating
    const totalRating = shooter.ratings.reduce((sum, r) => sum + r.rating, 0);
    shooter.averageRating = totalRating / shooter.ratings.length;

    // Update reliability based on recent performance
    this.updateReliabilityScore(shooter);
  }

  /**
   * Helper methods
   */
  private async notifyEligibleShooters(opportunity: ShootingOpportunity): Promise<void> {
    const eligibleShooters = await this.findEligibleShooters(opportunity.id);
    
    for (const shooter of eligibleShooters) {
      if (shooter.preferences.notifications.email || 
          shooter.preferences.notifications.sms || 
          shooter.preferences.notifications.push) {
        
        await this.sendNotification(shooter, {
          type: 'new_opportunity',
          title: `New ${opportunity.jobType} opportunity`,
          message: `${opportunity.title} on ${opportunity.date.toDateString()}`,
          data: { opportunityId: opportunity.id }
        });
      }
    }
  }

  private async processAutoApplications(opportunity: ShootingOpportunity): Promise<void> {
    const eligibleShooters = await this.findEligibleShooters(opportunity.id);
    
    for (const shooter of eligibleShooters) {
      if (shooter.preferences.autoAccept.enabled) {
        const distance = this.calculateDistance(
          shooter.location.coordinates,
          opportunity.location.coordinates
        );
        
        if (distance <= shooter.preferences.autoAccept.conditions.maxDistance &&
            opportunity.compensation.amount >= shooter.preferences.autoAccept.conditions.minRate) {
          
          await this.applyForOpportunity(shooter.id, opportunity.id, {
            message: 'Auto-applied based on preferences',
            availability: 'confirmed'
          });
        }
      }
    }
  }

  private calculateDistance(coord1: { lat: number; lng: number }, coord2: { lat: number; lng: number }): number {
    // Haversine formula for calculating distance between two points
    const R = 3959; // Earth's radius in miles
    const dLat = this.toRadians(coord2.lat - coord1.lat);
    const dLng = this.toRadians(coord2.lng - coord1.lng);
    
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(this.toRadians(coord1.lat)) * Math.cos(this.toRadians(coord2.lat)) *
              Math.sin(dLng / 2) * Math.sin(dLng / 2);
    
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  private toRadians(degrees: number): number {
    return degrees * (Math.PI / 180);
  }

  private isShooterAvailable(shooter: SecondShooter, date: Date, startTime: string, endTime: string): boolean {
    // Check if shooter has availability for the requested time
    const dateStr = date.toISOString().split('T')[0];
    
    return shooter.availability.some(slot => {
      const slotDate = slot.date.toISOString().split('T')[0];
      return slotDate === dateStr && 
             slot.type === 'available' &&
             slot.startTime <= startTime &&
             slot.endTime >= endTime;
    });
  }

  private isExperienceLevelSufficient(shooterLevel: ShooterSkill['level'], requiredLevel: ShooterSkill['level']): boolean {
    const levels = { beginner: 1, intermediate: 2, advanced: 3, expert: 4 };
    return levels[shooterLevel] >= levels[requiredLevel];
  }

  private hasRequiredEquipment(shooter: SecondShooter, requiredEquipment: string[]): boolean {
    const shooterEquipment = shooter.equipment.map(eq => `${eq.type}:${eq.brand}:${eq.model}`);
    return requiredEquipment.every(req => 
      shooterEquipment.some(eq => eq.toLowerCase().includes(req.toLowerCase()))
    );
  }

  private async notifyPrimaryPhotographer(opportunity: ShootingOpportunity, application: OpportunityApplication): Promise<void> {
    // Implementation for notifying primary photographer
    console.log(`Notifying primary photographer about new application for ${opportunity.title}`);
  }

  private async notifyApplicationResults(opportunity: ShootingOpportunity): Promise<void> {
    // Implementation for notifying all applicants about results
    console.log(`Notifying applicants about results for ${opportunity.title}`);
  }

  private async createCalendarEvent(opportunity: ShootingOpportunity, shooterId: string): Promise<void> {
    // Implementation for creating calendar event
    console.log(`Creating calendar event for shooter ${shooterId} and opportunity ${opportunity.title}`);
  }

  private calculateTotalEarnings(shooterId: string): number {
    // Mock calculation - in real implementation, sum up completed job payments
    const shooter = this.shooters.get(shooterId);
    return shooter ? shooter.completedJobs * shooter.rates.fullDay * 0.7 : 0;
  }

  private async checkForNewMatches(shooterId: string): Promise<void> {
    // Check if updated availability creates new opportunity matches
    const opportunities = await this.getOpportunitiesForShooter(shooterId);
    const shooter = this.shooters.get(shooterId);
    
    if (shooter && opportunities.length > 0) {
      await this.sendNotification(shooter, {
        type: 'new_matches',
        title: 'New opportunities available',
        message: `${opportunities.length} new opportunities match your availability`,
        data: { count: opportunities.length }
      });
    }
  }

  private updateReliabilityScore(shooter: SecondShooter): void {
    // Calculate reliability based on recent ratings and job completion
    const recentRatings = shooter.ratings.slice(-10); // Last 10 ratings
    if (recentRatings.length > 0) {
      const avgReliability = recentRatings.reduce((sum, r) => sum + r.categories.reliability, 0) / recentRatings.length;
      shooter.reliability = avgReliability / 5; // Convert to 0-1 scale
    }
  }

  private async sendNotification(shooter: SecondShooter, notification: {
    type: string;
    title: string;
    message: string;
    data?: any;
  }): Promise<void> {
    // Implementation for sending notifications
    console.log(`Sending ${notification.type} notification to ${shooter.name}: ${notification.message}`);
  }
}

export default SecondShooterPoolingService;
export type { 
  SecondShooter, 
  ShootingOpportunity, 
  OpportunityApplication, 
  AvailabilitySlot,
  ShooterSkill,
  PoolingNetwork
};
