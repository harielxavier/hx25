import { 
  collection, 
  doc, 
  getDocs, 
  getDoc, 
  addDoc, 
  updateDoc, 
  deleteDoc, 
  query, 
  where, 
  orderBy, 
  limit, 
  serverTimestamp,
  increment,
  Timestamp,
  DocumentData,
  QuerySnapshot,
  DocumentSnapshot,
  writeBatch,
  FieldValue
} from 'firebase/firestore';
import { ref, uploadBytes, getDownloadURL, deleteObject } from 'firebase/storage';
import { db, storage } from '../firebase/config';
import { getStockImage } from '../utils/images';
import type { StockImageCategory } from '../utils/images';
import { transformImageUrl } from '../utils/imageOptimizationUtils';

// Consistent interfaces with camelCase naming throughout
export interface Author {
  name: string;
  avatar: string;
  bio?: string;
}

export interface BlogPost {
  id: string;
  title: string;
  slug: string;
  excerpt: string;
  content: string;
  featuredImage: string;
  category: string;
  tags: string[];
  status: 'draft' | 'published' | 'scheduled';
  views: number;
  author: Author;
  publishedAt?: Timestamp | FieldValue;
  createdAt: Timestamp | FieldValue;
  updatedAt: Timestamp | FieldValue;
  seoTitle?: string;
  seoDescription?: string;
  featured?: boolean;
  videoEmbed?: string;
  commentsEnabled?: boolean;
  readTime?: number;
}

// Helper function to sanitize image URLs
export const sanitizeImageUrl = (url: string | undefined, category: StockImageCategory = 'wedding'): string => {
  // If URL is undefined, null, or empty string, return a stock image
  if (!url || url === '') {
    return getStockImage(category);
  }
  
  // If it's a relative path starting with /, it's a valid local image
  if (url.startsWith('/')) {
    // Check if it's pointing to one of our stock images
    if (url.includes('/images/stock/')) {
      return url;
    }
    
    // For other local paths, we'll assume they're valid
    return url;
  }
  
  try {
    // Check if URL is valid - just validate without storing the object
    new URL(url);
    
    // Additional validation for common issues
    if (url.includes('undefined') || url === 'null') {
      throw new Error('Invalid URL containing undefined or null');
    }
    
    // For external URLs, return them without logging
    return transformImageUrl(url);
  } catch (error) {
    // Silently handle errors and return fallback image
    // Return a stock image based on the category
    return getStockImage(category);
  }
};

// Helper function to convert Firestore data to BlogPost
const convertToPost = (id: string, data: DocumentData): BlogPost => {
  return {
    id,
    title: data.title || '',
    slug: data.slug || '',
    excerpt: data.excerpt || '',
    content: data.content || '',
    featuredImage: sanitizeImageUrl(data.featuredImage || data.image, (data.category || 'wedding') as StockImageCategory),
    category: data.category || '',
    tags: data.tags || [],
    author: {
      name: data.author?.name || 'Admin',
      avatar: sanitizeImageUrl(data.author?.avatar, 'wedding'),
      bio: data.author?.bio || ''
    },
    status: data.status || 'draft',
    views: data.views || 0,
    publishedAt: data.publishedAt,
    createdAt: data.createdAt || Timestamp.now(),
    updatedAt: data.updatedAt || Timestamp.now(),
    seoTitle: data.seoTitle || data.seo?.title,
    seoDescription: data.seoDescription || data.seo?.description,
    featured: data.featured || false,
    videoEmbed: data.videoEmbed || '',
    commentsEnabled: data.commentsEnabled !== false,
    readTime: data.readTime
  };
};

// Get all blog posts
export const getAllPosts = async (includeUnpublished = false): Promise<BlogPost[]> => {
  try {
    // Get posts from Firestore
    const postsRef = collection(db, 'posts');
    
    // Create a query based on whether we want unpublished posts
    const baseQuery = includeUnpublished
      ? query(postsRef, orderBy('createdAt', 'desc'))
      : query(postsRef, where('status', '==', 'published'), orderBy('publishedAt', 'desc'));
    
    const querySnapshot = await getDocs(baseQuery);
    
    if (querySnapshot.empty) {
      console.log('No blog posts found in Firestore');
      return [];
    }
    
    return querySnapshot.docs.map(doc => convertToPost(doc.id, doc.data()));
  } catch (error) {
    console.error('Error fetching blog posts:', error);
    return [];
  }
};

// Get a single blog post by ID
export const getPostById = async (id: string): Promise<BlogPost | null> => {
  try {
    const docSnapshot = await getDoc(doc(db, 'posts', id));
    
    if (!docSnapshot.exists()) {
      console.log(`No blog post found with ID: ${id}`);
      return null;
    }
    
    return convertToPost(docSnapshot.id, docSnapshot.data());
  } catch (error) {
    console.error(`Error fetching blog post with ID: ${id}`, error);
    return null;
  }
};

// Get a single blog post by slug
export const getPostBySlug = async (slug: string): Promise<BlogPost | null> => {
  try {
    const blogPostsRef = collection(db, 'posts');
    const q = query(
      blogPostsRef,
      where('slug', '==', slug),
      where('status', '==', 'published')
    );
    
    const querySnapshot = await getDocs(q);
    
    if (querySnapshot.empty) {
      console.log(`No blog post found with slug: ${slug}`);
      return null;
    }
    
    return convertToPost(querySnapshot.docs[0].id, querySnapshot.docs[0].data());
  } catch (error) {
    console.error(`Error fetching blog post with slug: ${slug}`, error);
    return null;
  }
};

// Create a new blog post
export const createPost = async (postData: Omit<BlogPost, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> => {
  try {
    // Prepare data for Firestore
    const now = serverTimestamp();
    const firestoreData = {
      ...postData,
      createdAt: now,
      updatedAt: now,
      views: 0
    };
    
    // Add document to Firestore
    const docRef = await addDoc(collection(db, 'posts'), firestoreData);
    console.log('Blog post created with ID:', docRef.id);
    
    return docRef.id;
  } catch (error) {
    console.error('Error creating blog post:', error);
    throw error;
  }
};

// Update an existing blog post
export const updatePost = async (id: string, postData: Partial<BlogPost>): Promise<boolean> => {
  try {
    // Prepare data for Firestore
    const firestoreData = {
      ...postData,
      updatedAt: serverTimestamp()
    };
    
    // Remove id field if present
    if ('id' in firestoreData) {
      delete firestoreData.id;
    }
    
    // If status is being changed to published and there's no publishedAt date, add one
    if (postData.status === 'published') {
      const docSnap = await getDoc(doc(db, 'posts', id));
      if (docSnap.exists()) {
        const currentData = docSnap.data();
        if (currentData.status !== 'published' || !currentData.publishedAt) {
          firestoreData.publishedAt = serverTimestamp();
        }
      }
    }
    
    // If featured is being set to true, unfeature all other posts
    if (postData.featured === true) {
      // Get all currently featured posts
      const postsRef = collection(db, 'posts');
      const featuredQuery = query(
        postsRef,
        where('featured', '==', true)
      );
      
      const featuredSnapshot = await getDocs(featuredQuery);
      
      // Unfeature all posts except the current one
      const batch = writeBatch(db);
      featuredSnapshot.docs.forEach(docSnapshot => {
        if (docSnapshot.id !== id) {
          batch.update(doc(db, 'posts', docSnapshot.id), { featured: false });
        }
      });
      
      await batch.commit();
    }
    
    // Update document in Firestore
    await updateDoc(doc(db, 'posts', id), firestoreData);
    console.log('Blog post updated:', id);
    
    return true;
  } catch (error) {
    console.error('Error updating blog post:', error);
    return false;
  }
};

// Check if a post is already published
export const getPostPublishStatus = async (id: string): Promise<boolean> => {
  try {
    const docSnap = await getDoc(doc(db, 'posts', id));
    if (!docSnap.exists()) {
      return false;
    }
    
    return docSnap.data().status === 'published';
  } catch (error) {
    console.error('Error checking post publish status:', error);
    return false;
  }
};

// Delete a blog post
export const deletePost = async (id: string): Promise<boolean> => {
  try {
    // Get the post data first to check for images to delete
    const docSnap = await getDoc(doc(db, 'posts', id));
    
    if (!docSnap.exists()) {
      console.log('Post not found for deletion:', id);
      return false;
    }
    
    const postData = docSnap.data();
    
    // Delete the document from Firestore
    await deleteDoc(doc(db, 'posts', id));
    console.log('Blog post deleted:', id);
    
    // If there's a featured image stored in Firebase Storage, delete it too
    if (postData.featuredImage && postData.featuredImage.includes('firebase')) {
      try {
        // Extract the path from the URL
        const url = new URL(postData.featuredImage);
        const path = url.pathname.split('/o/')[1];
        
        if (path) {
          const decodedPath = decodeURIComponent(path.split('?')[0]);
          const imageRef = ref(storage, decodedPath);
          await deleteObject(imageRef);
          console.log('Featured image deleted:', decodedPath);
        }
      } catch (imageError) {
        console.error('Error deleting featured image:', imageError);
        // Continue even if image deletion fails
      }
    }
    
    return true;
  } catch (error) {
    console.error('Error deleting blog post:', error);
    return false;
  }
};

// Upload a featured image for a blog post
export const uploadFeaturedImage = async (file: File): Promise<string> => {
  try {
    const timestamp = new Date().getTime();
    const storageRef = ref(storage, `blog/${timestamp}_${file.name}`);
    
    // Upload the file
    await uploadBytes(storageRef, file);
    
    // Get download URL
    const downloadURL = await getDownloadURL(storageRef);
    console.log('Image uploaded successfully:', downloadURL);
    
    return downloadURL;
  } catch (error) {
    console.error('Error uploading image:', error);
    throw error;
  }
};

// Increment post views
export const incrementPostViews = async (id: string): Promise<boolean> => {
  try {
    await updateDoc(doc(db, 'posts', id), {
      views: increment(1),
      updatedAt: serverTimestamp()
    });
    
    return true;
  } catch (error) {
    console.error('Error incrementing post views:', error);
    return false;
  }
};

// Get featured posts for the home page
export const getFeaturedPosts = async (limit = 3): Promise<BlogPost[]> => {
  try {
    const postsRef = collection(db, 'posts');
    
    // Query for featured posts
    const featuredQuery = query(
      postsRef,
      where('status', '==', 'published'),
      where('featured', '==', true),
      orderBy('publishedAt', 'desc'),
      limit(limit)
    );
    
    const querySnapshot = await getDocs(featuredQuery);
    
    if (querySnapshot.empty) {
      console.log('No featured posts found');
      
      // If no featured posts, get the most recent posts
      const recentQuery = query(
        postsRef,
        where('status', '==', 'published'),
        orderBy('publishedAt', 'desc'),
        limit(1)
      );
      
      const recentSnapshot = await getDocs(recentQuery);
      
      if (recentSnapshot.empty) {
        return [];
      }
      
      return recentSnapshot.docs.map(doc => convertToPost(doc.id, doc.data()));
    }
    
    return querySnapshot.docs.map(doc => convertToPost(doc.id, doc.data()));
  } catch (error) {
    console.error('Error fetching featured posts:', error);
    
    try {
      // Fallback to a simpler query if the complex one fails
      const simpleQuery = query(
        collection(db, 'posts'),
        where('status', '==', 'published'),
        orderBy('publishedAt', 'desc'),
        limit(limit * 2)
      );
      
      const simpleSnapshot = await getDocs(simpleQuery);
      
      if (simpleSnapshot.empty) {
        return [];
      }
      
      // Filter for featured posts client-side
      const allPosts = simpleSnapshot.docs.map(doc => convertToPost(doc.id, doc.data()));
      const featuredPosts = allPosts.filter(post => post.featured);
      
      if (featuredPosts.length > 0) {
        return featuredPosts.slice(0, limit);
      }
      
      // If no featured posts, return the most recent ones
      return allPosts.slice(0, 1);
    } catch (fallbackError) {
      console.error('Error with fallback query:', fallbackError);
      return [];
    }
  }
};

// Get posts by category
export const getPostsByCategory = async (category: string): Promise<BlogPost[]> => {
  try {
    const postsRef = collection(db, 'posts');
    const q = query(
      postsRef,
      where('status', '==', 'published'),
      where('category', '==', category),
      orderBy('publishedAt', 'desc')
    );
    
    const querySnapshot = await getDocs(q);
    
    if (querySnapshot.empty) {
      console.log(`No posts found in category: ${category}`);
      return [];
    }
    
    return querySnapshot.docs.map(doc => convertToPost(doc.id, doc.data()));
  } catch (error) {
    console.error(`Error fetching posts by category: ${category}`, error);
    return [];
  }
};

// Get posts by tag
export const getPostsByTag = async (tag: string): Promise<BlogPost[]> => {
  try {
    const postsRef = collection(db, 'posts');
    const q = query(
      postsRef,
      where('status', '==', 'published'),
      where('tags', 'array-contains', tag),
      orderBy('publishedAt', 'desc')
    );
    
    const querySnapshot = await getDocs(q);
    
    if (querySnapshot.empty) {
      console.log(`No posts found with tag: ${tag}`);
      return [];
    }
    
    return querySnapshot.docs.map(doc => convertToPost(doc.id, doc.data()));
  } catch (error) {
    console.error(`Error fetching posts by tag: ${tag}`, error);
    return [];
  }
};

// Search posts
export const searchPosts = async (searchQuery: string): Promise<BlogPost[]> => {
  try {
    // Get all published posts and filter client-side
    const postsRef = collection(db, 'posts');
    const q = query(
      postsRef,
      where('status', '==', 'published'),
      orderBy('publishedAt', 'desc')
    );
    
    const querySnapshot = await getDocs(q);
    
    if (querySnapshot.empty) {
      console.log('No posts found for search');
      return [];
    }
    
    const posts = querySnapshot.docs.map(doc => convertToPost(doc.id, doc.data()));
    
    // Filter posts client-side for basic search functionality
    return filterPostsBySearch(posts, searchQuery);
  } catch (error) {
    console.error(`Error searching posts for: ${searchQuery}`, error);
    return [];
  }
};

// Helper function to filter posts by search query
const filterPostsBySearch = (posts: BlogPost[], searchQuery: string): BlogPost[] => {
  const searchLower = searchQuery.toLowerCase();
  return posts.filter(post => (
    post.title.toLowerCase().includes(searchLower) ||
    post.excerpt.toLowerCase().includes(searchLower) ||
    post.content.toLowerCase().includes(searchLower) ||
    post.category.toLowerCase().includes(searchLower) ||
    post.tags.some(tag => tag.toLowerCase().includes(searchLower))
  ));
};

export default {
  getAllPosts,
  getPostById,
  getPostBySlug,
  createPost,
  updatePost,
  deletePost,
  uploadFeaturedImage,
  incrementPostViews,
  getFeaturedPosts,
  getPostsByCategory,
  getPostsByTag,
  searchPosts
};
